<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Terminal Cities – World Editor</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.10/dist/tweakpane.min.js"></script>

<script>
/* =====================================================
   CORE
===================================================== */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  5000
);

const renderer = new THREE.WebGLRenderer({ antialias:false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x111111);
document.body.appendChild(renderer.domElement);

/* =====================================================
   CAMERA SYSTEM (PLAYCANVAS STYLE)
===================================================== */
const cameraTarget = new THREE.Vector3();
let camRadius = 40;
let camTheta = Math.PI / 4;
let camPhi   = Math.PI / 3;
let camVelocity = { theta:0, phi:0 };
let camMode = null;
let camStart = {x:0,y:0};

const camKeys = { w:0,a:0,s:0,d:0,q:0,e:0,shift:0,ctrl:0 };

renderer.domElement.addEventListener("contextmenu", e => e.preventDefault());

window.addEventListener("keydown", e=>{
  const k = e.key.toLowerCase();
  if(k in camKeys) camKeys[k]=1;
  if(e.key==="Shift") camKeys.shift=1;
  if(e.key==="Control") camKeys.ctrl=1;
  if(k==="f" && selected) cameraTarget.copy(selected.position);
});

window.addEventListener("keyup", e=>{
  const k = e.key.toLowerCase();
  if(k in camKeys) camKeys[k]=0;
  if(e.key==="Shift") camKeys.shift=0;
  if(e.key==="Control") camKeys.ctrl=0;
});

renderer.domElement.addEventListener("mousedown", e=>{
  if(e.button===2 || (e.altKey && e.button===0)) camMode="orbit";
  else if(e.button===1) camMode="pan";
  camStart={x:e.clientX,y:e.clientY};
});

renderer.domElement.addEventListener("mousemove", e=>{
  if(!camMode) return;
  const dx=e.clientX-camStart.x;
  const dy=e.clientY-camStart.y;

  if(camMode==="orbit"){
    camVelocity.theta -= dx*0.002;
    camVelocity.phi   -= dy*0.002;
  }

  if(camMode==="pan"){
    const pan=0.02*camRadius;
    cameraTarget.x -= dx*pan*Math.cos(camTheta);
    cameraTarget.z += dx*pan*Math.sin(camTheta);
    cameraTarget.y += dy*pan;
  }

  camStart={x:e.clientX,y:e.clientY};
});

renderer.domElement.addEventListener("mouseup", ()=>camMode=null);

renderer.domElement.addEventListener("wheel", e=>{
  camRadius *= 1 + e.deltaY*0.001;
  camRadius = Math.max(5, Math.min(500, camRadius));
});

/* =====================================================
   ENVIRONMENT
===================================================== */
scene.add(new THREE.GridHelper(500,500,0x444444,0x222222));
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(20,40,20);
scene.add(sun);

/* =====================================================
   DATA
===================================================== */
let objects=[];
let selected=null;

/* =====================================================
   UI – INSPECTOR
===================================================== */
const pane=new Tweakpane.Pane({title:"Editor"});

const inspector={
  px:0,py:0,pz:0,
  rx:0,ry:0,rz:0,
  sx:1,sy:1,sz:1
};

const add=pane.addFolder({title:"Add Object"});
add.addButton({title:"➕ Box"}).on("click",()=>spawn("Box"));
add.addButton({title:"➕ Cylinder"}).on("click",()=>spawn("Cylinder"));
add.addButton({title:"➕ Sphere"}).on("click",()=>spawn("Sphere"));

const insp=pane.addFolder({title:"Inspector"});

function bind(key,apply){
  insp.addInput(inspector,key).on("change",e=>{
    if(!selected) return;
    apply(e.value);
    syncFromObject();
  });
}

bind("px",v=>selected.position.x=v);
bind("py",v=>selected.position.y=v);
bind("pz",v=>selected.position.z=v);

bind("rx",v=>selected.rotation.x=THREE.MathUtils.degToRad(v));
bind("ry",v=>selected.rotation.y=THREE.MathUtils.degToRad(v));
bind("rz",v=>selected.rotation.z=THREE.MathUtils.degToRad(v));

bind("sx",v=>selected.scale.x=v);
bind("sy",v=>selected.scale.y=v);
bind("sz",v=>selected.scale.z=v);

/* =====================================================
   OBJECT FACTORY
===================================================== */
function createObject(type){
  let g;
  if(type==="Box") g=new THREE.BoxGeometry(2,1,2);
  if(type==="Cylinder") g=new THREE.CylinderGeometry(1,1,1,16);
  if(type==="Sphere") g=new THREE.SphereGeometry(1,16,12);
  const m=new THREE.Mesh(g,new THREE.MeshStandardMaterial({color:0x888888}));
  m.position.y=0.5;
  return m;
}

function spawn(type){
  const o=createObject(type);
  scene.add(o);
  objects.push(o);
  select(o);
}

/* =====================================================
   GIZMO (ALWAYS VISIBLE, CAMERA-SCALED)
===================================================== */
const gizmo=new THREE.Group();
scene.add(gizmo);
gizmo.visible=false;

function gizmoMaterial(color){
  return new THREE.MeshBasicMaterial({
    color,
    depthTest:false,
    depthWrite:false
  });
}

function axis(color,axis,rx,rz,pos){
  const m=new THREE.Mesh(
    new THREE.CylinderGeometry(0.1,0.1,4,8),
    gizmoMaterial(color)
  );
  m.rotation.set(rx||0,0,rz||0);
  m.position.copy(pos);
  m.userData.axis=axis;
  m.renderOrder=999;
  return m;
}

gizmo.add(
  axis(0xff0000,"x",0,Math.PI/2,new THREE.Vector3(2,0,0)),
  axis(0x00ff00,"y",0,0,new THREE.Vector3(0,2,0)),
  axis(0x0000ff,"z",Math.PI/2,0,new THREE.Vector3(0,0,2))
);

/* =====================================================
   RAYCAST + DRAG
===================================================== */
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let dragging=false,activeAxis=null,startMouse,startPos;

window.addEventListener("mousedown",e=>{
  if(e.button!==0) return;

  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  if(selected){
    const g=raycaster.intersectObjects(gizmo.children);
    if(g.length){
      activeAxis=g[0].object.userData.axis;
      dragging=true;
      startMouse={x:e.clientX,y:e.clientY};
      startPos=selected.position.clone();
      return;
    }
  }

  const hit=raycaster.intersectObjects(objects);
  if(hit.length) select(hit[0].object);
});

window.addEventListener("mousemove",e=>{
  if(!dragging||!selected) return;
  const dx=e.clientX-startMouse.x;
  const dy=e.clientY-startMouse.y;

  if(activeAxis==="x") selected.position.x=startPos.x+dx*0.05;
  if(activeAxis==="y") selected.position.y=startPos.y-dy*0.05;
  if(activeAxis==="z") selected.position.z=startPos.z-dy*0.05;

  gizmo.position.copy(selected.position);
  syncFromObject();
});

window.addEventListener("mouseup",()=>dragging=false);

/* =====================================================
   SELECTION + SYNC
===================================================== */
function select(o){
  if(selected) selected.material.emissive.setHex(0x000000);
  selected=o;
  selected.material.emissive.setHex(0x333333);
  gizmo.visible=true;
  gizmo.position.copy(o.position);
  syncFromObject();
}

function syncFromObject(){
  if(!selected) return;
  inspector.px=selected.position.x;
  inspector.py=selected.position.y;
  inspector.pz=selected.position.z;

  inspector.rx=THREE.MathUtils.radToDeg(selected.rotation.x);
  inspector.ry=THREE.MathUtils.radToDeg(selected.rotation.y);
  inspector.rz=THREE.MathUtils.radToDeg(selected.rotation.z);

  inspector.sx=selected.scale.x;
  inspector.sy=selected.scale.y;
  inspector.sz=selected.scale.z;

  pane.refresh();
}

/* =====================================================
   GIZMO CAMERA SCALE
===================================================== */
function updateGizmoScale(){
  if(!selected) return;
  const d=camera.position.distanceTo(gizmo.position);
  const s=d*0.08;
  gizmo.scale.setScalar(s);
}

/* =====================================================
   LOOP
===================================================== */
function animate(){
  requestAnimationFrame(animate);

  let speed=0.6;
  if(camKeys.shift) speed*=3;
  if(camKeys.ctrl) speed*=0.3;

  const forward=new THREE.Vector3(-Math.sin(camTheta),0,-Math.cos(camTheta));
  const right=new THREE.Vector3(Math.cos(camTheta),0,-Math.sin(camTheta));

  if(camKeys.w) cameraTarget.addScaledVector(forward,speed);
  if(camKeys.s) cameraTarget.addScaledVector(forward,-speed);
  if(camKeys.a) cameraTarget.addScaledVector(right,-speed);
  if(camKeys.d) cameraTarget.addScaledVector(right,speed);
  if(camKeys.q) cameraTarget.y-=speed;
  if(camKeys.e) cameraTarget.y+=speed;

  camTheta+=camVelocity.theta;
  camPhi+=camVelocity.phi;
  camVelocity.theta*=0.85;
  camVelocity.phi*=0.85;
  camPhi=Math.max(0.1,Math.min(Math.PI-0.1,camPhi));

  camera.position.set(
    cameraTarget.x+camRadius*Math.sin(camPhi)*Math.sin(camTheta),
    cameraTarget.y+camRadius*Math.cos(camPhi),
    cameraTarget.z+camRadius*Math.sin(camPhi)*Math.cos(camTheta)
  );
  camera.lookAt(cameraTarget);

  updateGizmoScale();
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
